<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cymber Penis</title>
    <link rel="icon" href="../../images/duzypenisstudios/favicon.png" type="image/png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body {
    background: linear-gradient(to bottom, #220000, #440000);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: 'Arial', sans-serif;
    overflow: hidden;
    touch-action: none;
}
#gameCanvas {
    border: 3px solid #ff0000;
    border-radius: 10px;
    box-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000, 0 0 60px #ff0000;
    filter: blur(0.5px);
    max-width: 100%;
    max-height: 80vh;
}
#scoreBoard {
    position: relative;
    font-size: 4vw;
    font-weight: 700;
    color: #ff0000;
    text-shadow: 0 0 5px #ff0000, 0 0 10px #ff0000, 0 0 15px #ff0000;
    margin-bottom: 10px;
}
#startButton, #soundToggle, #pauseButton {
    font-size: 24px;
    padding: 10px 20px;
    background-color: #ff0000;
    color: #000;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 20px;
    text-shadow: 0 0 5px #330000;
}
#soundToggle, #pauseButton {
    margin-left: 10px;
}
#authContainer, #userInfo {
    margin-bottom: 10px;
    color: #ff0000;
}
#authContainer input, #authContainer button, #userInfo button {
    margin-right: 5px;
    padding: 5px;
    background-color: #330000;
    color: #ff0000;
    border: 1px solid #ff0000;
}
@media (min-width: 768px) {
    #scoreBoard {
        font-size: 24px;
    }
}
@keyframes sadFaceAnimation {
    0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
    50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
}
@keyframes happyFaceAnimation {
    0% { transform: translate(-50%, -50%) scale(0) rotate(0deg); opacity: 0; }
    50% { transform: translate(-50%, -50%) scale(1.2) rotate(180deg); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(1) rotate(360deg); opacity: 1; }
}
#sadFace, #happyFace {
    position: absolute;
    top: 50%;
    left: 50%;
    font-size: 100px;
    opacity: 0;
    pointer-events: none;
}
#sadFace {
    animation: sadFaceAnimation 1s ease-out;
    animation-fill-mode: forwards;
}
#happyFace {
    animation: happyFaceAnimation 1s ease-out;
    animation-fill-mode: forwards;
}
#speedSelector {
    margin-top: 20px;
    color: #fff;
    font-size: 18px;
}
#speedSelector label {
    margin-right: 15px;
    cursor: pointer;
}
#speedSelector input[type="radio"] {
    margin-right: 5px;
}
</style>
</head>
<body>
<div id="authContainer" style="display: none;">
  <input type="text" id="username" placeholder="Username">
  <input type="password" id="password" placeholder="Password">
  <button id="loginBtn">Login</button>
  <button id="registerBtn">Register</button>
</div>
<div id="userInfo" style="display: none;">
  <span id="loggedInUser"></span>
  <button id="logoutBtn">Logout</button>
</div>
<div id="scoreBoard">PLAYER: 0     IA: 0 | Rank: Silver 1</div>
<canvas id="gameCanvas"></canvas>
<div id="sadFace" style="display: none;">üòü</div>
<div id="happyFace" style="display: none;">üòÉ</div>
<div>
    <button id="startButton">Start Game</button>
    <button id="soundToggle">üîä Sound On</button>
    <button id="pauseButton">‚è∏Ô∏è Pause</button>
</div>
<div id="speedSelector">
    <label><input type="radio" name="speed" value="normal" checked> Normal</label>
</div>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreBoard = document.getElementById('scoreBoard');
const startButton = document.getElementById('startButton');
const soundToggle = document.getElementById('soundToggle');
const pauseButton = document.getElementById('pauseButton');
const sadFace = document.getElementById('sadFace');
const happyFace = document.getElementById('happyFace');
const speedSelector = document.getElementById('speedSelector');

let currentUser = null;

function showAuthForm() {
  document.getElementById('authContainer').style.display = 'block';
  document.getElementById('userInfo').style.display = 'none';
  startButton.style.display = 'none';
}

function showUserInfo() {
  document.getElementById('authContainer').style.display = 'none';
  document.getElementById('userInfo').style.display = 'block';
  document.getElementById('loggedInUser').textContent = `Logged in as: ${currentUser}`;
  startButton.style.display = 'inline-block';
}

function register() {
  const username = document.getElementById('username').value;
  const password = document.getElementById('password').value;
  if (username && password) {
    const users = JSON.parse(localStorage.getItem('users') || '{}');
    if (users[username]) {
      alert('Username already exists');
    } else {
      users[username] = { password, rank: 0, score: 0 };
      localStorage.setItem('users', JSON.stringify(users));
      login(username);
    }
  }
}

function login(username) {
  const users = JSON.parse(localStorage.getItem('users') || '{}');
  if (users[username]) {
    currentUser = username;
    playerRank = users[username].rank;
    playerScore = users[username].score;
    showUserInfo();
    updateScore();
  }
}

function logout() {
  currentUser = null;
  showAuthForm();
}

function saveProgress() {
  if (currentUser) {
    const users = JSON.parse(localStorage.getItem('users') || '{}');
    users[currentUser].rank = playerRank;
    users[currentUser].score = playerScore;
    localStorage.setItem('users', JSON.stringify(users));
  }
}

document.getElementById('registerBtn').addEventListener('click', register);
document.getElementById('loginBtn').addEventListener('click', () => login(document.getElementById('username').value));
document.getElementById('logoutBtn').addEventListener('click', logout);

// Existing game variables
let paddle, aiPaddle, puck, goal;
let gameStarted = false;
let soundOn = true;
let speed = 'normal';
let gameSpeed = 1;
let isPaused = false;

// Add these variables at the beginning of the script
let playerScore = 0, aiScore = 0;
let playerRank = 0;
const ranks = ['Silver 1', 'Silver 2', 'Silver 3', 'Gold 1', 'Gold 2', 'Sheriff', 'Supreme', 'CyberElite'];

// Web Audio API setup
let audioContext;
let masterGainNode;

function initAudio() {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    masterGainNode = audioContext.createGain();
    masterGainNode.connect(audioContext.destination);
    masterGainNode.gain.value = 0.5; // Adjust overall volume
}

function playSound(type, frequency, duration) {
    if (!soundOn || !audioContext) return;

    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();

    oscillator.type = type;
    oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
    
    gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

    oscillator.connect(gainNode);
    gainNode.connect(masterGainNode);

    oscillator.start();
    oscillator.stop(audioContext.currentTime + duration);
}

function playHitSound() {
    playSound('sine', 440, 0.1); // A4 note, short duration
}

function playGoalSound(scorer) {
    if (scorer === 'Player') {
        playSound('square', 440, 0.3); // A4 note, square wave for player
    } else {
        playSound('sawtooth', 220, 0.3); // A3 note, sawtooth wave for AI
    }
}

function playWinSound() {
    playSound('square', 880, 0.5); // A5 note, even longer duration
}

function playArpeggio() {
    if (!soundOn || !audioContext) return;

    const notes = [261.63, 329.63, 392.00, 523.25]; // C4, E4, G4, C5
    const duration = 0.2;

    notes.forEach((frequency, index) => {
        setTimeout(() => {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

            gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

            oscillator.connect(gainNode);
            gainNode.connect(masterGainNode);

            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        }, index * duration * 1000);
    });
}

function updateRank() {
    if (playerScore >= 7) {
        playerRank = Math.min(playerRank + 1, ranks.length - 1);
        playerScore = 0;
        aiScore = 0;
    }
}

function initializeGameObjects() {
    paddle = {radius: canvas.width * 0.0625, color: '#ff0000'};  // Changed to red
    aiPaddle = {radius: canvas.width * 0.0625, speed: canvas.width * 0.009, color: '#800080'};  // Changed to purple
    puck = {radius: canvas.width * 0.0375, speed: canvas.width * 0.0225};
    goal = {width: canvas.width * 0.375, height: canvas.height * 0.0167};
}

function resizeCanvas() {
    const maxWidth = window.innerWidth * 0.9;
    const maxHeight = window.innerHeight * 0.8;
    const aspectRatio = 2 / 3;

    let newWidth, newHeight;

    if (maxWidth / aspectRatio <= maxHeight) {
        newWidth = maxWidth;
        newHeight = maxWidth / aspectRatio;
    } else {
        newHeight = maxHeight;
        newWidth = maxHeight * aspectRatio;
    }

    canvas.width = newWidth;
    canvas.height = newHeight;

    initializeGameObjects();

    // Reset positions
    resetPositions();
}

function resetPositions() {
    paddle.x = canvas.width / 2;
    paddle.y = canvas.height - paddle.radius * 2;
    aiPaddle.x = canvas.width / 2;
    aiPaddle.y = aiPaddle.radius * 2;
    resetPuck();
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas();  // Initial call to set up the canvas

let lastScoreTime = 0, puckStuckTime = 0, aiWaitTime = 0, aiState = 'normal';
let goalEffect = {active: false, startTime: 0, scorer: ''};
let particles = [];
let fireworks = [];
let lastTime = 0;
const targetFPS = 60;
const targetFrameTime = 1000 / targetFPS;
const simulationSpeedMultiplier = 1.8;

function resetPuck() {
    puck.x = canvas.width / 2;
    puck.y = canvas.height / 2;
    puck.dx = 0;
    puck.dy = 0;
}

function launchPuck() {
    const angle = Math.random() * Math.PI * 2;
    puck.dx = Math.cos(angle) * puck.speed * gameSpeed;
    puck.dy = Math.sin(angle) * puck.speed * gameSpeed;
}

resetPuck();

function drawTable() {
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#220000');
    gradient.addColorStop(1, '#440000');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = 'rgba(255, 0, 0, 0.05)';
    for (let i = 0; i < canvas.width; i += 20) {
        for (let j = 0; j < canvas.height; j += 20) {
            ctx.beginPath();
            ctx.arc(i, j, 1, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    // Draw center line
    ctx.beginPath();
    ctx.moveTo(0, canvas.height / 2);
    ctx.lineTo(canvas.width, canvas.height / 2);
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Draw center circle
    ctx.shadowBlur = 20;
    ctx.shadowColor = '#ff0000';
    ctx.beginPath();
    ctx.arc(canvas.width / 2, canvas.height / 2, canvas.width * 0.125, 0, Math.PI * 2);
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Enhance goal areas
    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
    ctx.fillRect((canvas.width - goal.width) / 2, -5, goal.width, goal.height * 3);
    ctx.fillRect((canvas.width - goal.width) / 2, canvas.height - goal.height * 3, goal.width, goal.height * 3);
    
    // Draw side borders with glow effect
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#ff0000';
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(0, canvas.height);
    ctx.moveTo(canvas.width, 0);
    ctx.lineTo(canvas.width, canvas.height);
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 4;
    ctx.stroke();
    
    ctx.shadowBlur = 0;

    // Add this at the end of the function
    ctx.font = `bold ${canvas.width * 0.03}px Arial`;
    ctx.fillStyle = '#ff0000';
    ctx.textAlign = 'left';
    ctx.fillText(`Rank: ${ranks[playerRank]}`, 10, 30);
}

function drawPaddle(x, y, r, color) {
    ctx.save();
    ctx.shadowBlur = 30;
    ctx.shadowColor = color;

    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    
    ctx.beginPath();
    ctx.arc(x, y, r * 0.8, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    ctx.lineWidth = r * 0.1;
    ctx.stroke();
    
    ctx.beginPath();
    ctx.arc(x, y, r * 0.5, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.lineWidth = r * 0.05;
    ctx.stroke();
    
    ctx.restore();
}

function drawPuck() {
    ctx.save();
    ctx.shadowBlur = 30;
    ctx.shadowColor = '#FFA500';
    
    ctx.beginPath();
    ctx.arc(puck.x, puck.y, puck.radius, 0, Math.PI * 2);
    ctx.fillStyle = '#FFA500';
    ctx.fill();

    const gradient = ctx.createRadialGradient(puck.x, puck.y, 0, puck.x, puck.y, puck.radius);
    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
    gradient.addColorStop(1, 'rgba(255, 165, 0, 0.1)');
    ctx.fillStyle = gradient;
    ctx.fill();
    
    ctx.restore();
}

function createExplosion(x, y) {
    for (let i = 0; i < 30; i++) {  // Reduced number of particles
        particles.push({
            x, y,
            radius: Math.random() * 2 + 1,  // Smaller particles
            color: `hsl(${0 + Math.random() * 30},100%,50%)`,  // Red hue
            velocity: {
                x: (Math.random() - 0.5) * 6 * simulationSpeedMultiplier * gameSpeed,  // Adjusted for game speed
                y: (Math.random() - 0.5) * 6 * simulationSpeedMultiplier * gameSpeed
            },
            alpha: 1
        });
    }
}

function drawExplosion() {
    ctx.shadowBlur = 10;  // Reduced shadow blur
    particles.forEach((p, i) => {
        if (p.alpha <= 0) {
            particles.splice(i, 1);
        } else {
            p.velocity.y += 0.05 * simulationSpeedMultiplier * gameSpeed;
            p.x += p.velocity.x;
            p.y += p.velocity.y;
            p.alpha -= 0.03 * simulationSpeedMultiplier * gameSpeed;  // Faster fade out
            ctx.save();
            ctx.globalAlpha = p.alpha;
            ctx.shadowColor = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.fill();
            ctx.restore();
        }
    });
    ctx.shadowBlur = 0;
}

function createFirework() {
    const x = Math.random() * canvas.width;
    const y = canvas.height;
    const color = `hsl(${Math.random() * 360}, 100%, 50%)`;
    
    fireworks.push({
        x, y,
        color,
        radius: 2,
        velocity: {
            x: (Math.random() - 0.5) * 2 * gameSpeed,
            y: -Math.random() * 6 - 4 * gameSpeed  // Adjusted for game speed
        },
        gravity: 0.1 * gameSpeed,
        exploded: false,
        particles: []
    });
}

function updateFireworks() {
    fireworks = fireworks.filter(fw => {
        fw.x += fw.velocity.x;
        fw.y += fw.velocity.y;
        fw.velocity.y += fw.gravity;

        if (fw.velocity.y >= 0 && !fw.exploded) {
            fw.exploded = true;
            for (let i = 0; i < 30; i++) {  // Reduced number of particles
                const angle = Math.random() * Math.PI * 2;
                const speed = (Math.random() * 2 + 1) * gameSpeed;  // Adjusted for game speed
                fw.particles.push({
                    x: fw.x,
                    y: fw.y,
                    radius: Math.random() * 1.5 + 0.5,  // Smaller particles
                    color: fw.color,
                    velocity: {
                        x: Math.cos(angle) * speed,
                        y: Math.sin(angle) * speed
                    },
                    gravity: 0.05 * gameSpeed,
                    alpha: 1
                });
            }
        }

        fw.particles = fw.particles.filter(p => {
            p.x += p.velocity.x;
            p.y += p.velocity.y;
            p.velocity.y += p.gravity;
            p.alpha -= 0.02 * gameSpeed;  // Faster fade out
            return p.alpha > 0;
        });

        return !(fw.exploded && fw.particles.length === 0);
    });
}

function drawFireworks() {
    ctx.shadowBlur = 10;  // Reduced shadow blur
    fireworks.forEach(fw => {
        if (!fw.exploded) {
            ctx.beginPath();
            ctx.arc(fw.x, fw.y, fw.radius, 0, Math.PI * 2);
            ctx.fillStyle = fw.color;
            ctx.fill();
        }
        
        fw.particles.forEach(p => {
            ctx.save();
            ctx.globalAlpha = p.alpha;
            ctx.shadowColor = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.fill();
            ctx.restore();
        });
    });
    ctx.shadowBlur = 0;
}

function movePaddle(x, y) {
    let rect = canvas.getBoundingClientRect();
    paddle.x = Math.min(Math.max(x - rect.left, paddle.radius), canvas.width - paddle.radius);
    paddle.y = Math.min(Math.max(y - rect.top, canvas.height / 2 + paddle.radius), canvas.height - paddle.radius);
}

function handleMouseMove(e) {
    if (!isPaused) {
        movePaddle(e.clientX, e.clientY);
    }
}

function handleTouchMove(e) {
    if (!isPaused) {
        e.preventDefault();
        const touch = e.touches[0];
        movePaddle(touch.clientX, touch.clientY);
    }
}

function isPuckStuck() {
    return puck.y < canvas.height / 4 && (puck.x < puck.radius * 2 || puck.x > canvas.width - puck.radius * 2);
}

function moveAIPaddle() {
    const centerX = aiPaddle.x;
    const distanceFromCenter = Math.abs(centerX - canvas.width / 2);
    
    if (aiState === 'normal' && isPuckStuck()) {
        aiState = 'retreating';
        puckStuckTime = 0;
    }
    
    if (aiState === 'retreating') {
        const targetX = canvas.width / 2;
        const targetY = aiPaddle.radius;
        const dx = targetX - aiPaddle.x;
        const dy = targetY - aiPaddle.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance > aiPaddle.speed) {
            aiPaddle.x += dx / distance * aiPaddle.speed * simulationSpeedMultiplier * gameSpeed;
            aiPaddle.y += dy / distance * aiPaddle.speed * simulationSpeedMultiplier * gameSpeed;
        } else {
            aiPaddle.x = targetX;
            aiPaddle.y = targetY;
            aiState = 'waiting';
            aiWaitTime = 0;
        }
    } else if (aiState === 'waiting') {
        aiWaitTime += simulationSpeedMultiplier * gameSpeed;
        if (aiWaitTime > 60) {  // Wait for 1 second (60 frames)
            aiState = 'playing';
        }
    } else if (aiState === 'playing') {
        if (Math.abs(puck.x - centerX) > 5) {
            aiPaddle.x += puck.x > centerX ? aiPaddle.speed * simulationSpeedMultiplier * gameSpeed : -aiPaddle.speed * simulationSpeedMultiplier * gameSpeed;
        }
        aiPaddle.y = Math.min(aiPaddle.y + aiPaddle.speed * simulationSpeedMultiplier * gameSpeed, canvas.height / 2 - aiPaddle.radius);
        if (aiPaddle.y === canvas.height / 2 - aiPaddle.radius) {
            aiState = 'normal';
        }
    } else if (aiState === 'normal') {
        if (puck.y < canvas.height / 2) {
            if (Math.abs(puck.x - centerX) > 5) {
                aiPaddle.x += puck.x > centerX ? aiPaddle.speed * simulationSpeedMultiplier * gameSpeed : -aiPaddle.speed * simulationSpeedMultiplier * gameSpeed;
            }
            if (puck.y > aiPaddle.y && Math.abs(puck.x - centerX) < 50) {
                aiPaddle.y += aiPaddle.speed * simulationSpeedMultiplier * gameSpeed;
            } else {
                aiPaddle.y += (50 - aiPaddle.y) * 0.05 * simulationSpeedMultiplier * gameSpeed;
            }
        } else {
            if (distanceFromCenter > 70) {
                aiPaddle.x += (canvas.width / 2 - centerX) * 0.03 * simulationSpeedMultiplier * gameSpeed;
            } else if (Math.abs(puck.x - centerX) > 10) {
                aiPaddle.x += puck.x > centerX ? aiPaddle.speed * simulationSpeedMultiplier * gameSpeed : -aiPaddle.speed * simulationSpeedMultiplier * gameSpeed;
            }
            aiPaddle.y += (50 - aiPaddle.y) * 0.05 * simulationSpeedMultiplier * gameSpeed;
        }
    }
    
    aiPaddle.x = Math.min(Math.max(aiPaddle.x, aiPaddle.radius), canvas.width - aiPaddle.radius);
    aiPaddle.y = Math.min(Math.max(aiPaddle.y, aiPaddle.radius), canvas.height / 2 - aiPaddle.radius);
}

function collisionDetection() {
    if (puck.x + puck.dx > canvas.width - puck.radius || puck.x + puck.dx < puck.radius) {
        puck.dx = -puck.dx;
        playHitSound();
    }
    if ((puck.y + puck.dy > canvas.height - puck.radius && (puck.x <= (canvas.width - goal.width) / 2 || puck.x >= (canvas.width + goal.width) / 2)) ||
        (puck.y + puck.dy < puck.radius && (puck.x <= (canvas.width - goal.width) / 2 || puck.x >= (canvas.width + goal.width) / 2))) {
        puck.dy = -puck.dy;
        playHitSound();
    }
    
    const distancePlayer = Math.hypot(puck.x - paddle.x, puck.y - paddle.y);
    const distanceAI = Math.hypot(puck.x - aiPaddle.x, puck.y - aiPaddle.y);
    
    if (distancePlayer < puck.radius + paddle.radius) {
        const angle = Math.atan2(puck.y - paddle.y, puck.x - paddle.x);
        puck.dx = Math.cos(angle) * puck.speed * gameSpeed;
        puck.dy = Math.sin(angle) * puck.speed * gameSpeed;
        playHitSound();
    }
    if (distanceAI < puck.radius + aiPaddle.radius) {
        const angle = Math.atan2(puck.y - aiPaddle.y, puck.x - aiPaddle.x);
        puck.dx = Math.cos(angle) * puck.speed * gameSpeed;
        puck.dy = Math.sin(angle) * puck.speed * gameSpeed;
        playHitSound();
    }
    
    if (puck.y > canvas.height - puck.radius && puck.x > (canvas.width - goal.width) / 2 && puck.x < (canvas.width + goal.width) / 2) {
        aiScore++;
        resetPuck();
        lastScoreTime = Date.now();
        goalEffect = {active: true, startTime: Date.now(), scorer: 'AI'};
        createExplosion(puck.x, canvas.height);
        playGoalSound('AI');
        showSadFace();
    } else if (puck.y < puck.radius && puck.x > (canvas.width - goal.width) / 2 && puck.x < (canvas.width + goal.width) / 2) {
        playerScore++;
        resetPuck();
        lastScoreTime = Date.now();
        goalEffect = {active: true, startTime: Date.now(), scorer: 'Player'};
        createExplosion(puck.x, 0);
        playGoalSound('Player');
        showHappyFace();
    }
    
    puck.x = Math.min(Math.max(puck.x, puck.radius), canvas.width - puck.radius);
    puck.y = Math.min(Math.max(puck.y, puck.radius), canvas.height - puck.radius);
}

function showSadFace() {
    sadFace.style.display = 'block';
    setTimeout(() => {
        sadFace.style.display = 'none';
    }, 1000);
}

function showHappyFace() {
    happyFace.style.display = 'block';
    setTimeout(() => {
        happyFace.style.display = 'none';
    }, 1000);
}

function updateScore() {
    scoreBoard.innerHTML = `Player: ${playerScore} | AI: ${aiScore} | Rank: ${ranks[playerRank]}`;
    if (playerScore >= 7 || aiScore >= 7) {
        if (playerScore >= 7) {
            playArpeggio();
            startFireworksShow();
            updateRank();
        } else {
            playWinSound();
        }
        playerScore = 0;
        aiScore = 0;
        gameStarted = false;
        startButton.style.display = 'inline-block';
        speedSelector.style.display = 'block';
        saveProgress();  // Save progress after updating rank
    }
}

// Modify the startButton event listener
startButton.addEventListener('click', () => {
    if (currentUser) {
        if (!gameStarted) {
            gameStarted = true;
            startButton.style.display = 'none';
            speedSelector.style.display = 'none';
            resetPositions();
            lastScoreTime = Date.now();
            if (!audioContext) {
                initAudio();
            }
            requestAnimationFrame(draw);
        }
    } else {
        alert('Please login or register to start the game');
        showAuthForm();
    }
});

function startFireworksShow() {
    let fireworksCount = 0;
    const fireworksInterval = setInterval(() => {
        createFirework();
        fireworksCount++;
        if (fireworksCount >= 10) {  // Reduced number of fireworks
            clearInterval(fireworksInterval);
        }
    }, 500);  // Increased interval between fireworks
}

function drawCountdown(text) {
    ctx.fillStyle = 'rgba(51,0,0,0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.font = `bold ${canvas.width * 0.18}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'rgba(51,0,0,0.5)';
    ctx.fillText(text, canvas.width / 2 + 4, canvas.height / 2 + 4);
    ctx.fillStyle = '#ff0000';  // Updated text color
    ctx.shadowBlur = 20;
    ctx.shadowColor = '#ff0000';  // Updated shadow color
    ctx.fillText(text, canvas.width / 2, canvas.height / 2);
    ctx.shadowBlur = 0;
}

function draw(currentTime) {
    const deltaTime = currentTime - lastTime;
    if (deltaTime < targetFrameTime) {
        requestAnimationFrame(draw);
        return;
    }
    lastTime = currentTime - (deltaTime % targetFrameTime);

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawTable();
    drawPaddle(paddle.x, paddle.y, paddle.radius, paddle.color);
    drawPaddle(aiPaddle.x, aiPaddle.y, aiPaddle.radius, aiPaddle.color);
    drawPuck();
    drawExplosion();
    updateFireworks();
    drawFireworks();
    
    if (gameStarted && !isPaused) {
        const now = Date.now();
        const timeSinceScore = (now - lastScoreTime) * simulationSpeedMultiplier * gameSpeed;
        
        if (timeSinceScore <= 3000) {
            if (timeSinceScore < 1000) {
                drawCountdown("3");
            } else if (timeSinceScore < 2000) {
                drawCountdown("2");
            } else if (timeSinceScore < 3000) {
                drawCountdown("1");
            }
        } else if (timeSinceScore < 3500) {
            drawCountdown("Go!");
        } else {
            puck.x += puck.dx * simulationSpeedMultiplier * gameSpeed;
            puck.y += puck.dy * simulationSpeedMultiplier * gameSpeed;
            collisionDetection();
            moveAIPaddle();
        }
        
        if (timeSinceScore === 3500) {
            launchPuck();
        }
        
        if (goalEffect.active) {
            const effectTime = (now - goalEffect.startTime) * simulationSpeedMultiplier * gameSpeed;
            if (effectTime < 1000) {
                ctx.font = `bold ${canvas.width * 0.06}px Arial`;
                ctx.fillStyle = '#ff0000';  // Updated effect color
                ctx.textAlign = 'center';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff0000';  // Updated effect shadow color
                ctx.fillText(goalEffect.scorer === 'Player' ? 'Player scored!' : 'AI scored!', canvas.width / 2, canvas.height / 2);
                ctx.shadowBlur = 0;
            } else {
                goalEffect.active = false;
            }
        }
        
        if (isPuckStuck()) {
            puckStuckTime += simulationSpeedMultiplier * gameSpeed;
            if (puckStuckTime > 180) {  // 3 seconds (60 frames per second * 3)
                resetPuck();
                launchPuck();
                puckStuckTime = 0;
            }
        } else {
            puckStuckTime = 0;
        }
    }
    
    updateScore();
    requestAnimationFrame(draw);
}

canvas.addEventListener('mousemove', handleMouseMove);
canvas.addEventListener('touchmove', handleTouchMove, {passive: false});

soundToggle.addEventListener('click', () => {
    soundOn = !soundOn;
    soundToggle.textContent = soundOn ? 'üîä Sound On' : 'üîá Sound Off';
});

pauseButton.addEventListener('click', () => {
    isPaused = !isPaused;
    pauseButton.textContent = isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
});

speedSelector.addEventListener('change', (e) => {
    if (e.target.type === 'radio') {
        speed = e.target.value;
        gameSpeed = 1;  // Set to normal speed
    }
});

// Initial draw call
requestAnimationFrame(draw);
showAuthForm();
</script>
</body>
</html>